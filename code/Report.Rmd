---
title: "Influencing Factors of Ghana Agricultural Profits Analysis"
by: Group 07 - Siqi Zhang, Huibo Jia, Qiyu Ye, Mark Russeff
output: html_notebook
---

```{r echo = FALSE, warning = FALSE}
library(tidyverse)
library(haven)
library(car)
library(here)

setwd(here())

source(here("code","helperFunc.R"))
```

## Read data

After reading through the documentation, we determined these data files contain the data we want to use to analyze the influencing factors of Ghana agricultural profits

```{r}
# list of data file pairs to read, first is subfolder, second is file name
datafiles <- list(c("aggregates/", "agg2"),
                  c("", "sec8b"),
                  c("", "sec0a"),
                  c("", "sec1"),
                  c("", "sec2a"),
                  c("", "sec8a2"),
                  c("", "sec8a3"),
                  c("", "sec8c1"),
                  c("", "sec8c2"),
                  c("community/", "cs2"))

invisible(sapply(datafiles, readRawData))
```

## Calculate agricultural profit per area unit

First we need to convert different area unit into a same one. Looking at count of each unit, acre is the major one, so we decide to map other units to acre. According to G4USERSG.pdf, we create a map between each unit to a multiplier of it when it's converted to acre (the "Other" unit is treated as NA). Then join the map onto `sec8b` and multiply with original land size to get unified land size (values greater than 1e+100 are treated as NA). We noticed that some households have multiple entries of land size info and among them there is NA value. So we convert NA to 0 so we can sum up land size for each household. Eventually, household with land size less than 0.5 acre are filtered out because that's probably not a real farm.

```{r}
# map land size units to acre with a multiplier (s8bq4bm)
# the "Other" unit is treated as NA
table(sec8b$s8bq4b)
land_size_unit_map <- data.frame("s8bq4b" = as.double(c(1:4)),
                                 "s8bq4bm" = c(1, 1, 1/9, NA))

# convert all land size to acre
land_size_info <- sec8b %>%
  select(clust, nh, s8bq4a, s8bq4b) %>%
  mutate(s8bq4a = ifelse(s8bq4a > 1e+100, NA, s8bq4a),
         s8bq4b = ifelse(s8bq4b > 1e+100, NA, s8bq4b)) %>%
  left_join(land_size_unit_map) %>%
  # s8bq4ac is corrected s8bq4a, which is land size in acre
  mutate(s8bq4ac = s8bq4a * s8bq4bm) %>%
  # convert NA to 0 to calculate sum of land size for each household
  replace(., is.na(.), 0) %>%
  group_by(clust, nh) %>%
  summarise(landSize = sum(s8bq4ac)) %>%
  # remove household with small land size
  filter(landSize >= 0.5)
```

Then we use agricultural income minus depreciation of farm equipment (`agri1 - hhagdepn`) as household profit, and devide it by household land size to get profit per area unit. `agg2` does not have NA value so no need to clean up.

```{r}
# identify count of NAs in agg2
colSums(is.na(agg2))

# check correlation between agricultural income and corrected agricultural income
cor(agg2$agri1, agg2$agri1c)

# resolve warnings during join
attr(agg2$clust, "label") <- "Enumeration Area number"
attr(agg2$nh, "label") <- "Household ID"

# calculate household agri profit per acre
# because the above correlations are both 1,
# use only "agri1" to calculate agricultural profit
hh_profit_info <- agg2 %>%
  select(clust, nh, agri1, hhagdepn) %>%
  filter(agri1 != 0) %>%
  inner_join(land_size_info, by = c("clust", "nh")) %>%
  mutate(profit = (agri1 - hhagdepn) / landSize) %>%
  select(-agri1, -hhagdepn, -landSize)

attr(hh_profit_info$profit, "label") <- "HH agri profit"
```

## Tidy household basic information

For basic household information, we are interested in language of respondent (values greater than 1e+100 are treated as "Unknown" language), ecological zone number and 3 different locality classifications. All variables are converted to factor type so they could be used as dummy variables in linear model.

```{r}
# household basic information
hh_basic_info <- sec0a %>%
  select(region, district, eanum, clust, nh, reslan, ez:loc3) %>%
  mutate(reslan = cleanAndFactorize(reslan, 1e+100, 99,
                                    levels = as.character(c(1:8, 99)),
                                    labels = c("English", "Akan", "Ewe", "GaAdangbe",
                                               "Dagbani", "Hausa", "Nzema", "Other", "Unknown")),
         ez = factor(ez,
                     levels = as.character(c(1:3)),
                     labels = c("Coastal", "Forest", "Savannah")),
         loc2 = factor(loc2,
                       levels = as.character(c(1,2)),
                       labels = c("Urban", "Rural")),
         loc5 = factor(loc5, 
                       levels = as.character(c(1:5)),
                       labels = c("Accra", "OtherUrban", "RuralCoastal",
                                  "RuralForest", "RuralSavannah")),
         loc3 = factor(loc3,
                       levels = as.character(c(1:3)),
                       labels = c("Accra", "OtherUrban", "Rural"))
  )
```

## Tidy household member information

Select information for household members and calculate mean, max and min age of household.

```{r}
# household member information
hhm_info <- sec1 %>%
  select(clust, nh, pid, sex, agey, rel) %>%
  group_by(clust, nh) %>%
  mutate(female = sex == 2,
         age = agey,
         avgAge = mean(agey),
         maxAge = max(agey),
         minAge = min(agey)
  ) %>%
  select(-sex, -agey)
```

Based on information from these two below sources, we categorize educational qualification (`s2aq3`) into 5 levels: "None", "BasicEducation", "SecondaryEducation", "TertiaryEducation" and "Other". For missing value in `s2aq3`, it's because these people never attended school (`s2aq1 == 2`). In this case we set education to None.

[Education System in Ghana](https://www.scholaro.com/pro/Countries/Ghana/Education-System)

[Education in Ghana Wikipedia](https://en.wikipedia.org/wiki/Education_in_Ghana)

Educational Qualification | Education Level
--------------------------|--------------------
01 None                   | None
02 MSLC?BECE              | BasicEducation
03 Voc/Comm               | SecondaryEducation
04 ‘O’ Level              | SecondaryEducation
05 SSS                    | SecondaryEducation
06 ‘A’ Level              | SecondaryEducation
07 T/T Cert. B            | TertiaryEducation
08 T /T Cert. A           | TertiaryEducation
09 Nursing                | TertiaryEducation
10 Tech/Prof Cert.        | TertiaryEducation
11 Tech/Prof Dip          | TertiaryEducation
12 Bachelor               | TertiaryEducation
13 Masters                | TertiaryEducation
14 Doctorate              | TertiaryEducation
96 Other                  | Other

```{r warning = FALSE}
# household member education information
# map education qualification to education level
educ_level_map <- data.frame("s2aq3" = c(1:14, 96),
                             "s2aq3l" = c(1, 2, rep(3, 4), rep(4, 8), 5))

# resolve warnings
attr(educ_level_map$s2aq3, "label") <- "Highest educ qualification"
attr(educ_level_map$s2aq3, "format.stata") <- "%10.0g"

# Check NAs
colSums(is.na(sec2a))

hhm_educ <- sec2a %>%
  select(clust, nh, pid, s2aq1, s2aq3) %>%
  # if never attended school (s2aq1 == 2), set education to None (s2aq3 = 1)
  mutate(s2aq3 = ifelse(s2aq1 == 2, 1, s2aq3)) %>%
  left_join(educ_level_map) %>%
  mutate(educ = factor(s2aq3l,
                       levels = as.character(c(1:5)),
                       labels = c("None", "BasicEducation", "SecondaryEducation",
                                  "TertiaryEducation", "Other"))) %>%
  select(-s2aq1, -s2aq3, -s2aq3l)
```

Then we join household member info and education info, and use info of household head as a representative of the household.

```{r}
hh_head_info <- hhm_info %>%
  inner_join(hhm_educ, by=c("clust", "nh", "pid")) %>%
  filter(rel == 1) %>% # head of household
  select(-pid, -rel)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
